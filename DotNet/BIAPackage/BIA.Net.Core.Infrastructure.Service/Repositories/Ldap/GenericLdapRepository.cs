// <auto-generated />
// <copyright file="GenericLdapRepository.cs" company="BIA">
// Copyright (c) BIA. All rights reserved.
// </copyright>

namespace BIA.Net.Core.Infrastructure.Service.Repositories
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Configuration;
    using System.DirectoryServices;
    using System.DirectoryServices.AccountManagement;
    using System.DirectoryServices.ActiveDirectory;
    using System.Linq;
    using System.Runtime.InteropServices;
    using System.Security.Cryptography;
    using System.Security.Principal;
    using System.Text.RegularExpressions;
    using System.Threading;
    using System.Threading.Tasks;
    using BIA.Net.Core.Common;
    using BIA.Net.Core.Common.Configuration;
    using BIA.Net.Core.Common.Helpers;
    using BIA.Net.Core.Domain.Authentication;
    using BIA.Net.Core.Domain.Dto.User;
    using BIA.Net.Core.Domain.RepoContract;
    using BIA.Net.Core.Domain.User.Services;
    using BIA.Net.Core.Infrastructure.Service.Repositories.Ldap;
    using Microsoft.Extensions.Configuration;
    using Microsoft.Extensions.Logging;
    using Microsoft.Extensions.Options;

    /// <summary>
    /// Helper to get information from Ldap.
    /// </summary>
    abstract public class GenericLdapRepository<TUserFromDirectoryDto, TUserFromDirectory> : IUserDirectoryRepository<TUserFromDirectoryDto, TUserFromDirectory>
        where TUserFromDirectoryDto : BaseUserFromDirectoryDto, new()
        where TUserFromDirectory : class, IUserFromDirectory, new()
    {
        /// <summary>
        /// The user identity key domain service.
        /// </summary>
        protected readonly IUserIdentityKeyDomainService userIdentityKeyDomainService;

        protected const string KeyPrefixCacheGroup = "BIAGroupSid:";

        protected const string KeyPrefixCacheUserSid = "BIAUserSid:";

        protected const string KeyPrefixCacheUserIdentityKey = "BIAUserIdentityKey:";

        protected const string KeyPrefixCacheUserSidHistory = "BIAUsersidHistory:";

        /// <summary>
        /// Groups cached.
        /// </summary>
        protected static readonly Dictionary<string, string> CacheGroupName = new Dictionary<string, string>();

        /// <summary>
        /// The logger.
        /// </summary>
        protected readonly ILogger<GenericLdapRepository<TUserFromDirectoryDto, TUserFromDirectory>> logger;

        /// <summary>
        /// The configuration of the BiaNet section.
        /// </summary>
        protected readonly BiaNetSection configuration;

        /// <summary>
        /// The configuration of the app settings section.
        /// </summary>
        protected readonly IConfiguration appConfiguration;

        /// <summary>
        /// The configuration of the BiaNet section.
        /// </summary>
        protected readonly IEnumerable<LdapDomain> ldapDomains;

        /// <summary>
        /// The configuration of the BiaNet section.
        /// </summary>
        protected readonly IEnumerable<LdapDomain> ldapDomainsUsers;

        /// <summary>
        /// The sidResolver.
        /// </summary>
        protected readonly LdapRepositoryHelper ldapRepositoryHelper;

        /// <summary>
        /// Duration of the cache for ldap Group Member List in ldap.
        /// </summary>
        protected readonly int LdapCacheGroupDuration;

        /// <summary>
        /// Duration of the cache for user property in ldap.
        /// </summary>
        protected readonly int LdapCacheUserDuration;

        /// <summary>
        /// Initializes a new instance of the <see cref="GenericLdapRepository"/> class.
        /// </summary>
        /// <param name="logger">The logger.</param>
        /// <param name="configuration">The configuration.</param>
        public GenericLdapRepository(
            ILogger<GenericLdapRepository<TUserFromDirectoryDto, TUserFromDirectory>> logger,
            IOptions<BiaNetSection> configuration,
            ILdapRepositoryHelper ldapRepositoryHelper,
            IUserIdentityKeyDomainService userIdentityKeyDomainService)
        {
            this.logger = logger;
            this.configuration = configuration.Value;
            this.ldapRepositoryHelper = (LdapRepositoryHelper)ldapRepositoryHelper;

            this.ldapDomains = this.configuration.Authentication?.LdapDomains;
            this.ldapDomainsUsers = this.ldapDomains?.Where(l => l.ContainsUser == true);
            this.LdapCacheGroupDuration = configuration.Value.Authentication?.LdapCacheGroupDuration ?? 200;
            this.LdapCacheUserDuration = configuration.Value.Authentication?.LdapCacheUserDuration ?? 1800;
            this.userIdentityKeyDomainService = userIdentityKeyDomainService;
        }

        /// <summary>
        /// Return the value of the property.
        /// </summary>
        /// <typeparam name="T">type of the value</typeparam>
        /// <param name="property">the property.</param>
        /// <returns>the value of the property.</returns>
        protected static T LdapGetValue<T>(PropertyValueCollection property)
        {
            object value = null;
            foreach (object tmpValue in property)
            {
                value = tmpValue;
            }

            return (T)value;
        }

        /// <summary>
        /// Return the domain of the Entity
        /// </summary>
        /// <param name="entry">the entry.</param>
        /// <returns>the </returns>
        protected static string LdapGetDomainName(DirectoryEntry entry)
        {
            if (entry == null || entry.Parent == null)
            {
                return null;
            }

            using DirectoryEntry parent = entry.Parent;
            if (LdapGetValue<string>(parent.Properties["objectClass"]) == "domainDNS")
            {
                return LdapGetValue<string>(parent.Properties["dc"]);
            }
            else
            {
                return LdapGetDomainName(parent);
            }
        }

        /// <summary>
        /// Convert the Ad entry in a UserInfoDirectory Object.
        /// </summary>
        /// <param name="entry">Entry from AD.</param>
        /// <param name="domainKey">Domain Name in config file where domain found.</param>
        protected abstract TUserFromDirectory ConvertToUserDirectory(DirectoryEntry entry, string domainKey);

        /// <inheritdoc />
        protected virtual async Task<bool> IsUserSidInGroups(string sid, IEnumerable<LdapGroup> ldapGroups)
        {
            if (ldapGroups == null || ldapGroups.Count() == 0)
            {
                return false;
            }
            ConcurrentBag<string> listUsersSid = new ConcurrentBag<string>();
            ConcurrentBag<string> listTreatedGroupSid = new ConcurrentBag<string>();
            var getListTasks = new List<Task>();
            foreach (var ldapGroup in ldapGroups)
            {
                getListTasks.Add(GetAllUsersSidInLdapGroup(listUsersSid, listTreatedGroupSid, ldapGroup));
            }
            while (getListTasks.Count > 0)
            {
                Task finishedTask = await Task.WhenAny(getListTasks);
                if (listUsersSid.Any(usid => usid == sid)) return true;
                getListTasks.Remove(finishedTask);
            }
            return false;

        }

        /// <inheritdoc />
        public virtual List<TUserFromDirectory> SearchUsers(string search, string ldapName = null, int max = 10)
        {
            List<TUserFromDirectory> usersInfo = new List<TUserFromDirectory>();

            // Sanitize unsafe characters from search value to avoid LDAP injections
            // See : https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html
            // Space are remove to search by FirstName LastName or LastName FirstName (coded in SearchUsersInDomain)
            const string rgxPattern = @"[\\#+<>,;""=*()]";
            search = Regex.Replace(search, rgxPattern, string.Empty);

            if (string.IsNullOrEmpty(search))
            {
                return usersInfo;
            }

            if (!string.IsNullOrEmpty(ldapName))
            {
                LdapDomain ldapDomain = ldapDomainsUsers.FirstOrDefault(e => e.LdapName == ldapName);
                if (ldapDomain != null)
                {
                    return SearchUsersInDomain(search, ldapDomain, max).Take(max).ToList();
                }
            }

            foreach (var ldapDomain in ldapDomainsUsers)
            {
                var results = SearchUsersInDomain(search, ldapDomain, max);
                if (results != null)
                {
                    usersInfo.AddRange(results.Take(max - usersInfo.Count));

                    if (usersInfo.Count >= max)
                    {
                        break;
                    }
                }
            }

            return usersInfo;
        }

        protected virtual IEnumerable<TUserFromDirectory> SearchUsersInDomain(string search, LdapDomain domain, int max)
        {
            if (domain == null || string.IsNullOrEmpty(domain.LdapName))
            {
                return null;
            }

            List<DirectoryEntry> usersMatches = new List<DirectoryEntry>();
            try
            {
                if (PrepareCredential(domain))
                {
                    string localLdapName;
                    if (!this.ldapRepositoryHelper.IsLocalServerOnADomain(out localLdapName))
                    {
                        using (DirectoryEntry localMachine = new DirectoryEntry("WinNT://" + Environment.MachineName))
                        {
                            foreach (DirectoryEntry child in localMachine.Children)
                            {
                                if (child.SchemaClassName == "User" && child.Name.Contains(search, StringComparison.OrdinalIgnoreCase))
                                {
                                    usersMatches.Add(child);
                                }
                            }
                        }
                    }
                    else
                    {
                        string ldapPath = $"LDAP://{domain.LdapName}";
                        if (domain.LdapName == ".")
                        {
                            ldapPath = $"LDAP://{localLdapName}";
                        }

                        if (!string.IsNullOrEmpty(domain.Filter))
                        {
                            ldapPath = $"LDAP://{domain.Filter}";
                        }

                        var cnSearch = "(&";
                        foreach (var searchPart in search.Split(" "))
                        {
                            if (!String.IsNullOrEmpty(searchPart))
                                cnSearch += $"(cn=*{searchPart}*)";
                        }
                        cnSearch += ")";

                        using var entry = new DirectoryEntry(ldapPath, domain.LdapServiceAccount, domain.LdapServicePass);
                        using var searcher = new DirectorySearcher(entry)
                        {
                            SearchScope = SearchScope.Subtree,
                            Filter = $"(&(objectCategory=person)(objectClass=user){cnSearch})",
                            //Filter = $"(&(objectCategory=person)(objectClass=user)(cn=*{search}*))",
                            SizeLimit = max
                        };
                        usersMatches.AddRange(searcher.FindAll().Cast<SearchResult>().Select(s => s.GetDirectoryEntry()).ToList());
                    }
                }
            }
            catch (Exception e)
            {
                this.logger.LogError(e, "Could not join Domain :{domain}", domain);
            }

            return usersMatches.Select((um) => ConvertToUserDirectory(um, domain.Name));
        }

        /// <inheritdoc />
        public virtual async Task<List<string>> AddUsersInGroup(IEnumerable<TUserFromDirectoryDto> usersFromDirectory, string roleLabel)
        {
            List<string> listGroupCacheSidToRemove = new List<string>();
            List<string> errors = new List<string>();
            try
            {
                foreach (var user in usersFromDirectory)
                {
                    if (!AddUserInGroup(user, roleLabel, listGroupCacheSidToRemove))
                    {
                        errors.Add(user.DisplayName);
                    }
                }
                foreach (var cacheSidToRemove in listGroupCacheSidToRemove)
                {
                    await this.ldapRepositoryHelper.DistributedCache.Remove(KeyPrefixCacheGroup + cacheSidToRemove);
                }
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "An error occured while adding the users with GUID : {userIds}", string.Join(',', usersFromDirectory.Select(u => u.DisplayName)));
            }
            return errors;
        }

        protected virtual bool AddUserInGroup(TUserFromDirectoryDto user, string roleLabel, List<string> listGroupCacheSidToRemove)
        {

            try
            {
                UserPrincipal userToAdd = ResolveUserPrincipal(user.Domain, user.IdentityKey).Result;

                if (userToAdd != null)
                {
                    this.logger.LogInformation("User Identity {identityKey} found  in domain {domain}", user.IdentityKey, user.Domain);
                    string domainWhereUserFound = user.Domain;

                    GroupPrincipal group = PrepareGroupOfRoleForUser(domainWhereUserFound, roleLabel);
                    if (group == null)
                    {
                        // TODO : just add in db IF mode fake
                        return false;
                    }
                    try
                    {
                        group.Members.Add(userToAdd);
                        group.Save();

                        if (!listGroupCacheSidToRemove.Contains(group.Sid.Value))
                        {
                            listGroupCacheSidToRemove.Add(group.Sid.Value);
                        }

                        return true;
                    }
                    catch (Exception e)
                    {
                        this.logger.LogError(e, "[AddUserInGroup] Error when adding user {userName} in group {groupName}", userToAdd.UserPrincipalName, group.UserPrincipalName);
                        return false;
                    }
                }
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "[AddUserInGroup] user IdentityKey {identityKey} problem with domain {domain}", user.IdentityKey, user.Domain);
            }

            return false;
        }

        protected virtual async Task<UserPrincipal> ResolveUserPrincipal(string domain, string identityKey)
        {
            PrincipalContext contextUser;

            contextUser = await PrepareDomainContext(domain);

            UserPrincipal userToAdd = null;

            if (contextUser != null)
            {
                userToAdd = UserPrincipal.FindByIdentity(contextUser, (IdentityType)this.userIdentityKeyDomainService.GetIdentityKeyType(), identityKey);
            }

            return userToAdd;
        }

        public virtual async Task<TUserFromDirectory> ResolveUser(TUserFromDirectoryDto userFromDirectoryDto)
        {
            UserPrincipal userPrincipal = null;
            if (userFromDirectoryDto.Domain != null)
            {
                userPrincipal = await ResolveUserPrincipal(userFromDirectoryDto.Domain, userFromDirectoryDto.IdentityKey);
            }
            else
            {
                foreach (var ldapDomainsUser in ldapDomainsUsers)
                {
                    userPrincipal = await ResolveUserPrincipal(ldapDomainsUser.Name, userFromDirectoryDto.IdentityKey);
                    if (userPrincipal != null)
                    {
                        break;
                    }
                }
            }
            if (userPrincipal == null) return null;
            return GetUser(userPrincipal, userFromDirectoryDto.Domain);
        }

        protected virtual GroupPrincipal PrepareGroupOfRoleForUser(string domainWhereUserFound, string roleLabel)
        {
            var userLdapGroups = this.GetLdapGroupsForRole(roleLabel);
            // Role role = this.configuration.Roles.Where(w => w.Type == BIAConstants.RoleType.Ldap && w.Label == roleLabel).FirstOrDefault();
            if (userLdapGroups != null && userLdapGroups.Count() > 0)
            {
                LdapGroup ldapGroup;
                PrincipalContext context;
                ldapGroup = userLdapGroups.Where(g => g.AddUsersOfDomains.Any(d => d == domainWhereUserFound)).FirstOrDefault();
                if (ldapGroup == null)
                {
                    this.logger.LogError("[AddUserInGroup] LdapGroup not found for domain {domainWhereUserFound} of role {roleLabel}", domainWhereUserFound, roleLabel);
                    return null;
                }
                context = PrepareDomainContext(ldapGroup.Domain).Result;
                if (context != null)
                {
                    var group = GroupPrincipal.FindByIdentity(context, ldapGroup.LdapName);
                    if (group == null)
                    {
                        this.logger.LogError("[AddUserInGroup] Cannot find group {groupName} in domain {domain}", ldapGroup.LdapName, ldapGroup.Domain);
                    }
                    return group;
                }
            }

            return null;
        }

        Dictionary<LdapDomain, PrincipalContext> PrincipalContextCache = new Dictionary<LdapDomain, PrincipalContext>();
        SemaphoreSlim mutex = new SemaphoreSlim(1);

        internal async Task<PrincipalContext> PrepareDomainContext(string domain)
        {

            LdapDomain adDomain = ldapDomains.Where(d => d.Name == domain).FirstOrDefault();
            if (adDomain == null && this.ldapRepositoryHelper.IsServerDomain(domain, false))
            {
                adDomain = ldapDomains.Where(d => d.Name == ".").FirstOrDefault();
            }
            PrincipalContext pc = await PrepareDomainContext(adDomain);
            return pc;
        }

        protected virtual async Task<PrincipalContext> PrepareDomainContext(LdapDomain domain)
        {
            await mutex.WaitAsync().ConfigureAwait(false);
            try
            {
                if (PrincipalContextCache.ContainsKey(domain))
                {
                    return PrincipalContextCache[domain];
                }
                if (PrepareCredential(domain))
                {
                    if (!string.IsNullOrEmpty(domain.LdapServiceAccount))
                    {
                        return new PrincipalContext(ContextType.Domain, domain.LdapName, domain.LdapServiceAccount, domain.LdapServicePass);
                    }
                    PrincipalContext pc;
                    if (domain.LdapName == ".")
                    {
                        string localLdapName;
                        if (this.ldapRepositoryHelper.IsLocalServerOnADomain(out localLdapName))
                        {
                            pc = new PrincipalContext(ContextType.Domain, localLdapName);
                        }
                        else
                        {
                            pc = new PrincipalContext(ContextType.Machine);
                        }
                    }
                    else
                    {
                        pc = new PrincipalContext(ContextType.Domain, domain.LdapName);
                    }
                    PrincipalContextCache.Add(domain, pc);
                    return pc;
                }
            }
            catch (Exception e)
            {
                logger.LogError(e, "Error when PrepareDomainContext for domain: {domain}", domain.LdapName);
            }
            finally
            {
                mutex.Release();
            }
            return null;
        }

        object syncPrepareCredential = new Object();
        /// <summary>
        /// Extract credential from vault if required
        /// </summary>
        /// <param name="domain"></param>
        /// <returns>true if ok</returns>
        protected virtual bool PrepareCredential(LdapDomain domain)
        {
            lock (syncPrepareCredential)
            {
                if (string.IsNullOrEmpty(domain.LdapServiceAccount) && !string.IsNullOrEmpty(domain.CredentialKeyInWindowsVault))
                {

                    try
                    {
                        (string UserName, string Password) cred = CredentialHelper.RetrieveCredentialsByVaultKey(domain.CredentialKeyInWindowsVault);
                        if (!string.IsNullOrWhiteSpace(cred.Password))
                        {
                            domain.LdapServiceAccount = cred.UserName;
                            domain.LdapServicePass = cred.Password;
                            return true;
                        }
                        this.logger.LogError("[PrepareCredential] Credential {credentialKeyInWindowsVault} not found in Vault", domain.CredentialKeyInWindowsVault);
                        return false;
                    }
                    catch (Exception ex)
                    {
                        this.logger.LogError(ex, "[PrepareCredential] Error when search credential {credentialKeyInWindowsVault}", domain.CredentialKeyInWindowsVault);
                        return false;
                    }

                }
                return true;
            }
        }

        /// <inheritdoc />
        public virtual async Task<List<TUserFromDirectoryDto>> RemoveUsersInGroup(List<TUserFromDirectoryDto> usersFromRepositoryToRemove, string roleLabel)
        {
            List<string> listGroupCacheSidToRemove = new List<string>();

            List<TUserFromDirectoryDto> notRemovedUser = new List<TUserFromDirectoryDto>();

            try
            {
                foreach (var userToRemove in usersFromRepositoryToRemove)
                {
                    bool userRemoved = false;
                    foreach (var domain in ldapDomainsUsers)
                    {
                        // If the domain is not contains in user database all domain should be parsed to clean the group.
                        if (userToRemove.Domain == null || userToRemove.Domain.Equals(domain.Name))
                        {
                            UserPrincipal userPrincipalToRemove = await ResolveUserPrincipal(domain.Name, userToRemove.IdentityKey);

                            if (userPrincipalToRemove != null)
                            {
                                string domainWhereUserFound = domain.Name;
                                GroupPrincipal group = PrepareGroupOfRoleForUser(domainWhereUserFound, roleLabel);
                                if (group == null || !group.Members.Remove(userPrincipalToRemove/*context, IdentityType.Guid, userToRemove.Guid.ToString()*/))
                                {

                                }
                                else
                                {
                                    group.Save();
                                    userRemoved = true;
                                    if (!listGroupCacheSidToRemove.Contains(group.Sid.Value))
                                    {
                                        listGroupCacheSidToRemove.Add(group.Sid.Value);
                                    }
                                }
                            }
                        }
                    }
                    if (!userRemoved)
                    {
                        notRemovedUser.Add(userToRemove);
                        this.logger.LogError("[RemoveUsersInGroup] user not found in all adDomains : {userToRemove}({domain}\\{identityKey})", userToRemove.DisplayName, userToRemove.Domain, userToRemove.IdentityKey);
                    }
                }
                foreach (var cacheSidToRemove in listGroupCacheSidToRemove)
                {
                    await this.ldapRepositoryHelper.DistributedCache.Remove(KeyPrefixCacheGroup + cacheSidToRemove);
                }
            }
            catch (Exception exception)
            {
                this.logger.LogError(exception, "An error occured while adding the user with Identity Key : {identityKey}", string.Join(',', usersFromRepositoryToRemove.Select(u => $"{u.DisplayName}({u.IdentityKey})")));
                throw;
            }

            return notRemovedUser;
        }


        /// <summary>
        /// Check if a user is in a group.
        /// </summary>
        /// <param name="ldapGroups">The groups to search in.</param>
        /// <param name="login">The user login.</param>
        /// <returns>A boolean indicating whether the user is in the group.</returns>
        public virtual async Task<bool> IsSidInGroups(IEnumerable<LdapGroup> ldapGroups, string sid)
        {
            if (string.IsNullOrWhiteSpace(sid))
            {
                string msgLdap = "For retrieving roles from an LDAP group, the sid cannot be null";
                this.logger.LogWarning(msgLdap);
                throw new ArgumentNullException(nameof(sid), msgLdap);
            }

            return await IsUserSidInGroups(sid, ldapGroups);
        }

        /// <inheritdoc />
        public virtual async Task<IEnumerable<string>> GetAllUsersSidInRoleToSync(string role, bool forceRefresh = false)
        {
            this.cacheGroupPrincipal.Clear();
            List<LdapGroup> userLdapGroups = this.GetLdapGroupsForRole(role);
            if (userLdapGroups.Count == 0)
            {
                // no ldap group defined
                return null;
            }
            ConcurrentBag<string> listUsersSid = new ConcurrentBag<string>();
            if (userLdapGroups == null || userLdapGroups.Count() == 0)
            {
                return listUsersSid.ToList();
            }

            ConcurrentBag<string> listTreatedGroupSid = new ConcurrentBag<string>();
            var resolveTasks = new List<Task>();
            foreach (var ldapGroup in userLdapGroups)
            {
                resolveTasks.Add(GetAllUsersSidInLdapGroup(listUsersSid, listTreatedGroupSid, ldapGroup, forceRefresh));
            }
            await Task.WhenAll(resolveTasks);
            return listUsersSid.ToList();
        }

        /// <inheritdoc />
        public virtual List<LdapGroup> GetLdapGroupsForRole(string roleLabel)
        {
            return this.configuration.Roles.Where(w => (w.Type == BiaConstants.RoleType.Ldap || w.Type == BiaConstants.RoleType.Synchro) && w.Label == roleLabel).Select(r => r.LdapGroups).SelectMany(x => x).ToList();
        }

        static Dictionary<string, string> localCacheGroupSid = new Dictionary<string, string>();
        object syncLocalCacheGroupSid = new Object();
        protected virtual async Task GetAllUsersSidInLdapGroup(ConcurrentBag<string> listUsersSid, ConcurrentBag<string> listTreatedGroupSid, LdapGroup ldapGroup, bool forceRefresh = false)
        {
            string sid = "";
            lock (syncLocalCacheGroupSid)
            {
                localCacheGroupSid.TryGetValue(ldapGroup.Domain + ":" + ldapGroup.LdapName, out sid);

                if (string.IsNullOrEmpty(sid))
                {
                    GroupPrincipal groupPrincipal = null;
                    try
                    {
                        PrincipalContext ctx = PrepareDomainContext(ldapGroup.Domain).Result;
                        if (ctx != null)
                        {
                            groupPrincipal = GroupPrincipal.FindByIdentity(ctx, ldapGroup.LdapName);
                        }
                    }
                    catch (Exception e)
                    {
                        this.logger.LogWarning(e, "Could not join Domain :" + ldapGroup.Domain);
                        throw e;
                    }
                    if (groupPrincipal != null)
                    {
                        this.logger.LogInformation("Group " + ldapGroup.LdapName + " found in domain " + ldapGroup.Domain);
                        sid = groupPrincipal.Sid.Value;
                        localCacheGroupSid.Add(ldapGroup.Domain + ":" + ldapGroup.LdapName, sid);
                    }
                }
            }

            if (!string.IsNullOrEmpty(sid))
            {
                if (forceRefresh)
                {
                    await this.ldapRepositoryHelper.DistributedCache.Remove(KeyPrefixCacheGroup + sid);
                }

                await this.GetAllUsersSidFromGroupRecursivelyAsync(new GroupDomainSid() { Sid = sid, Domain = ldapGroup.Domain }, ldapGroup, listUsersSid, listTreatedGroupSid);
            }
        }

        /// <summary>
        /// Get all user from a group.
        /// </summary>
        /// <param name="groupPrincipalSid">The group sid to search in.</param>
        /// <param name="rootLdapGroup">the root ldapGroup to limite the scope of the search (ldap users and ldap for groups).</param>
        /// <param name="listUsers">The users found.</param>
        /// <param name="listTreatedGroups">The group already treated.</param>
        protected virtual async Task GetAllUsersSidFromGroupRecursivelyAsync(GroupDomainSid groupSid, LdapGroup rootLdapGroup, ConcurrentBag<string> listUsersSid, ConcurrentBag<string> listTreatedGroupSid)
        {
            SidResolvedGroup resolvedGroup = await ResolveGroupMember(groupSid, rootLdapGroup);
            if (resolvedGroup != null)
            {
                foreach (string sid in resolvedGroup.MembersUserSid)
                {
                    if (!listUsersSid.Contains(sid))
                    {
                        listUsersSid.Add(sid);
                    }
                }

                var resolveTasks = new List<Task>();
                foreach (GroupDomainSid memberGroupSid in resolvedGroup.MembersGroupSid)
                {
                    if (listTreatedGroupSid.Contains(memberGroupSid.Sid))
                    {
                        continue;
                    }
                    listTreatedGroupSid.Add(memberGroupSid.Sid);

                    resolveTasks.Add(GetAllUsersSidFromGroupRecursivelyAsync(memberGroupSid, rootLdapGroup, listUsersSid, listTreatedGroupSid));
                }
                await Task.WhenAll(resolveTasks);
            }
        }

        /// <summary>
        /// Get a user directory from a user principal.
        /// </summary>
        /// <param name="userPrincipal">The user principal.</param>
        /// <param name="domainKey">The domain Key (in config file).</param>
        /// <returns>The user AD.</returns>
        internal TUserFromDirectory GetUser(UserPrincipal userPrincipal, string domainKey)
        {
            return !(userPrincipal.GetUnderlyingObject() is DirectoryEntry entry) ? null : ConvertToUserDirectory(entry, domainKey);
        }

        /// <summary>
        /// Gets the user roles asynchronous.
        /// </summary>
        /// <param name="userInfoDto">The user information dto.</param>
        /// <param name="sid">The sid.</param>
        /// <param name="domain">The domain.</param>
        /// <returns>The list of roles.</returns>
        public virtual async Task<List<string>> GetUserRolesAsync(BiaClaimsPrincipal claimsPrincipal, UserInfoFromDBDto userInfoDto, string sid, string domain, bool withCredentials)
        {
            this.cacheGroupPrincipal.Clear();
            IEnumerable<BIA.Net.Core.Common.Configuration.Role> rolesSection = this.configuration.Roles;

            var globalRoles = new ConcurrentBag<string>();

            if (rolesSection != null)
            {
                var roleTasks = rolesSection.Select(async role =>
                {
                    switch (role.Type)
                    {
                        case BiaConstants.RoleType.Fake:
                            if (withCredentials)
                            {
                                return role.Label;
                            }
                            break;

                        case BiaConstants.RoleType.UserInDB:
                            if (userInfoDto?.IsActive == true)
                            {
                                return role.Label;
                            }
                            break;

                        case BiaConstants.RoleType.ClaimsToRole:
                            if (withCredentials && role.RequireClaim?.AllowedValues?.Any() == true && claimsPrincipal != null)
                            {
                                List<string> claimValues = claimsPrincipal.FindAll(role.RequireClaim.Type).Select(c => c.Value).ToList();
                                if (role.RequireClaim.AllowedValues.Intersect(claimValues).Any())
                                {
                                    return role.Label;
                                }
                            }
                            break;

                        case BiaConstants.RoleType.Ldap:
                        case BiaConstants.RoleType.LdapWithSidHistory:
                            if (withCredentials)
                            {
                                bool result = await this.IsSidInGroups(role.LdapGroups, sid);
                                if (result)
                                {
                                    return role.Label;
                                }
                                else if (role.Type.Equals(BiaConstants.RoleType.LdapWithSidHistory))
                                {
                                    string sidHistory = GetSidHistory(sid, domain).Result;
                                    if (!string.IsNullOrEmpty(sidHistory))
                                    {
                                        if (IsSidInGroups(role.LdapGroups, sidHistory).Result)
                                        {
                                            return role.Label;
                                        }
                                    }
                                }
                            }
                            break;

                        default:
                            string msg = $"This type of role is not managed or is missing : {role.Type}";
                            this.logger.LogError(msg);
                            throw new ConfigurationErrorsException(msg);
                    }

                    return null;
                });

                string[] roles = await Task.WhenAll(roleTasks);
                foreach (var role in roles)
                {
                    if (role != null)
                    {
                        globalRoles.Add(role);
                    }
                }
            }

            return globalRoles.ToList();
        }

        protected virtual async Task<string> GetSidHistory(string sid, string userDomain)
        {
            string sidHistory = (string)await this.ldapRepositoryHelper.LocalCache.Get<string>(KeyPrefixCacheUserSidHistory + sid);
            if (sidHistory != null)
            {
                return sidHistory;
            }
            PrincipalContext searchContext = PrepareDomainContext(userDomain).Result;
            UserPrincipal user = UserPrincipal.FindByIdentity(searchContext, IdentityType.Sid, sid);
            DirectoryEntry up_de = (DirectoryEntry)user?.GetUnderlyingObject();
            if (up_de != null)
            {
                up_de.RefreshCache(new[] { "sIDHistory" });
                byte[] sIDHistory = up_de.Properties["sIDHistory"]?.Value as byte[];
                if (sIDHistory != null)
                {
                    var securityIdentifier = new System.Security.Principal.SecurityIdentifier((byte[])sIDHistory, 0);
                    sidHistory = securityIdentifier.ToString();
                }
            }
            await this.ldapRepositoryHelper.LocalCache.Add(KeyPrefixCacheUserSidHistory + sid, sidHistory, this.LdapCacheUserDuration);
            return sidHistory;
        }

        protected virtual async Task<SidResolvedGroup> ResolveGroupMember(GroupDomainSid groupDomainSid, LdapGroup rootLdapGroup)
        {
            SidResolvedGroup itemResolve;
            itemResolve = await this.ldapRepositoryHelper.DistributedCache.Get<SidResolvedGroup>(KeyPrefixCacheGroup + groupDomainSid.Sid);
            if (itemResolve != null)
            {
                return itemResolve;
            }

            DateTime start = DateTime.Now;
            string groupName = "Name not found : " + groupDomainSid.Sid;

            bool ContainsOnlyUsers = false;
            bool IgnoreForeignSecurityPrincipalForGroup = false;
            if (rootLdapGroup.RecursiveGroupsOfDomains == null || rootLdapGroup.RecursiveGroupsOfDomains.Length == 0)
            {
                rootLdapGroup.RecursiveGroupsOfDomains = new string[] { rootLdapGroup.Domain };
                ContainsOnlyUsers = true;
                IgnoreForeignSecurityPrincipalForGroup = true;
            }
            else if (rootLdapGroup.RecursiveGroupsOfDomains.Count() == 1 && rootLdapGroup.RecursiveGroupsOfDomains[0] == rootLdapGroup.Domain)
            {
                IgnoreForeignSecurityPrincipalForGroup = true;
            }

            DomainGroupPrincipal subGroupPrincipal = ResolveGroupPrincipal(new string[] { groupDomainSid.Domain }, groupDomainSid.Sid);

            if (subGroupPrincipal.groupPrincipal != null)
            {
                groupName = subGroupPrincipal.groupPrincipal.Name;

                this.logger.LogDebug("ResolveGroupMember {0} => {1}\\{2} Member to solve : {3} ms", groupDomainSid.Sid, subGroupPrincipal.domain, groupName, (DateTime.Now - start).TotalMilliseconds);
                start = DateTime.Now;

                ConcurrentBag<GroupDomainSid> MembersGroupSid = new ConcurrentBag<GroupDomainSid>();
                ConcurrentBag<string> MembersUserSid = new ConcurrentBag<string>();

                DirectoryEntry de = (DirectoryEntry)subGroupPrincipal.groupPrincipal.GetUnderlyingObject();

                List<string> listSDN = new List<string>();
                foreach (string sDN in de.Properties["member"])
                {
                    listSDN.Add(sDN);
                }

                this.logger.LogDebug("ResolveGroupMember {0} => {1}\\{2} Member resolve : {3} ms", groupDomainSid.Sid, subGroupPrincipal.domain, groupName, (DateTime.Now - start).TotalMilliseconds);
                start = DateTime.Now;

                // do not parrallelize else to much ldap request and risque of reject by ad.
                foreach (var sDN in listSDN)
                //Parallel.ForEach(listSDN, sDN =>
                {
                    bool isForeignSecurity = sDN.Contains("ForeignSecurityPrincipals");
                    bool isUser = true;
                    bool isGroup = false;

                    string memberSid = null;
                    GroupDomainSid memberGroupSid = null;

                    if (isForeignSecurity)
                    {
                        string pattern = @"S-\d-\d-\d+-\d+-\d+-\d+-\w+";
                        foreach (Match match in Regex.Matches(sDN, pattern))
                        {
                            if (match.Success && match.Groups.Count > 0)
                            {
                                memberSid = match.Groups[0].Value;
                                break;
                            }
                        }
                        if (!IgnoreForeignSecurityPrincipalForGroup)
                        {
                            if (memberSid != null)
                            {
                                if (!ContainsOnlyUsers)
                                {
                                    this.logger.LogDebug("ResolveGroupMember test : {0}", memberSid);
                                    // Method for indeterminate group or user slower but work always.
                                    memberGroupSid = TestIfIsGroup(memberSid, rootLdapGroup.RecursiveGroupsOfDomains, subGroupPrincipal.domain, isForeignSecurity);
                                    if (memberGroupSid != null)
                                    {
                                        isGroup = true;
                                    }
                                    isUser = !isGroup;
                                }
                            }
                        }
                    }
                    else
                    {
                        DomainDirectoryEntry domainDirectoryEntry = GetDirectoryEntry(sDN);
                        if (domainDirectoryEntry.de != null)
                        {

                            memberSid = new SecurityIdentifier((byte[])domainDirectoryEntry.de.Properties["objectSid"].Value, 0).Value;

                            if (!ContainsOnlyUsers)
                            {
                                var objectClass = domainDirectoryEntry.de.Properties["objectClass"];

                                // For group check
                                isGroup = objectClass?.Contains("group") == true;
                                // For user check
                                isUser = objectClass?.Contains("user") == true;
                                if (isGroup && !isUser)
                                {
                                    memberGroupSid = new GroupDomainSid() { Sid = memberSid, Domain = domainDirectoryEntry.domain.Name };
                                }
                                else if ((!isGroup && !isUser) || (isGroup && isUser))
                                {
                                    this.logger.LogDebug("ResolveGroupMember test : {0}", memberSid);
                                    // Method for indeterminate group or user slower but work always.
                                    memberGroupSid = TestIfIsGroup(memberSid, rootLdapGroup.RecursiveGroupsOfDomains, domainDirectoryEntry.domain.Name, isForeignSecurity);
                                    if (memberGroupSid != null)
                                    {
                                        isGroup = true;
                                    }
                                    isUser = !isGroup;
                                }
                            }
                        }
                    }

                    if (memberSid != null)
                    {
                        if (isUser)
                        {
                            if (!MembersUserSid.Contains(memberSid))
                            {
                                MembersUserSid.Add(memberSid);
                            }
                        }
                        else if (isGroup)
                        {
                            if (!MembersGroupSid.Any(m => m.Sid == memberGroupSid.Sid))
                            {
                                MembersGroupSid.Add(memberGroupSid);
                            }

                        }
                    }
                }
                //);

                itemResolve = new SidResolvedGroup() { DomainKey = subGroupPrincipal.domain, MembersGroupSid = MembersGroupSid.ToList(), MembersUserSid = MembersUserSid.ToList(), Type = SidResolvedItemType.Group };
                await this.ldapRepositoryHelper.DistributedCache.Add(KeyPrefixCacheGroup + groupDomainSid.Sid, itemResolve, this.LdapCacheGroupDuration);

                this.logger.LogDebug("ResolveGroupMember {0} => {1}\\{2} Decripted with DirectoryEntry ({3} groups + {4} users) : {5} ms", groupDomainSid.Sid, subGroupPrincipal.domain, groupName, MembersGroupSid.Count, MembersUserSid.Count, (DateTime.Now - start).TotalMilliseconds);

                return itemResolve;
            }
            else
            {
                DateTime end = DateTime.Now;

                TimeSpan ts = (end - start);
                this.logger.LogDebug("ResolveGroupMember {0} not found in {1} : {2} ms", groupDomainSid.Sid, subGroupPrincipal.domain, ts.TotalMilliseconds);
                start = DateTime.Now;
            }

            // TODO ad cache unresolve item to reduce try

            this.logger.LogDebug("ResolveGroupMember {0} : {1} ms", groupName, (DateTime.Now - start).TotalMilliseconds);

            return null;
        }

        protected virtual GroupDomainSid TestIfIsGroup(string memberSid, string[] recursiveGroupsOfDomains, string currentDomain, bool isForeignSecurity)
        {
            GroupDomainSid memberGroupSid = null;
            DomainGroupPrincipal testIsGroup = isForeignSecurity ?
                ResolveGroupPrincipal(recursiveGroupsOfDomains.Where((val, idx) => val != currentDomain).ToArray(), memberSid) :
                ResolveGroupPrincipal(new string[] { currentDomain }, memberSid);

            if (testIsGroup.groupPrincipal != null)
            {
                memberGroupSid = new GroupDomainSid() { Sid = memberSid, Domain = testIsGroup.domain };
            }

            return memberGroupSid;
        }

        protected struct DomainDirectoryEntry
        {
            public LdapDomain domain;
            public DirectoryEntry de;
        }

        protected virtual DomainDirectoryEntry GetDirectoryEntry(string sDN)
        {
            DomainDirectoryEntry domainDirectoryEntry = new DomainDirectoryEntry() { domain = null, de = null };
            LdapDomain adDomain = ldapDomains.Where(d => d.LdapName.Split('.').All(subD => sDN.Contains("DC=" + subD))).FirstOrDefault();
            if (adDomain == null)
            {
                return domainDirectoryEntry;
            }

            domainDirectoryEntry.domain = adDomain;
            if (PrepareCredential(adDomain))
            {
                string ldapPath = $"LDAP://{adDomain.LdapName}/" + sDN;
                string localLdapName;
                if ((adDomain.LdapName == ".") && (this.ldapRepositoryHelper.IsLocalServerOnADomain(out localLdapName)))
                {
                    ldapPath = $"LDAP://{localLdapName}/" + sDN;
                }

                if (!string.IsNullOrEmpty(adDomain.LdapServiceAccount))
                {
                    domainDirectoryEntry.de = new DirectoryEntry(ldapPath, adDomain.LdapServiceAccount, adDomain.LdapServicePass);
                }
                else
                {
                    domainDirectoryEntry.de = new DirectoryEntry(ldapPath);
                }
            }

            return domainDirectoryEntry;
        }

        protected struct DomainGroupPrincipal
        {
            public string domain;
            public GroupPrincipal groupPrincipal;
        }

        Dictionary<string, DomainGroupPrincipal> cacheGroupPrincipal = new Dictionary<string, DomainGroupPrincipal>();
        object syncLocalGroupPrincipal = new Object();
        protected virtual DomainGroupPrincipal ResolveGroupPrincipal(string[] groupDomains, string sid)
        {
            DomainGroupPrincipal domainGroupPrincipal = new DomainGroupPrincipal() { domain = null, groupPrincipal = null };
            lock (syncLocalGroupPrincipal)
            {
                if (cacheGroupPrincipal.TryGetValue(sid, out domainGroupPrincipal))
                {
                    this.logger.LogDebug("ResolveGroupPrincipal {0} => trouvé dans le cache", sid);
                }
                else
                {
                    foreach (var groupDomain in groupDomains)
                    {

                        DateTime start = DateTime.Now;
                        try
                        {
                            PrincipalContext searchTestContext = PrepareDomainContext(groupDomain).Result;
                            if (searchTestContext != null)
                            {
                                domainGroupPrincipal.groupPrincipal = GroupPrincipal.FindByIdentity(searchTestContext, IdentityType.Sid, sid);
                            }
                        }
                        catch (Exception ex)
                        {
                            this.logger.LogWarning(ex, "Could not join Domain :" + groupDomain);
                            throw ex;
                        }

                        if (domainGroupPrincipal.groupPrincipal != null)
                        {
                            domainGroupPrincipal.domain = groupDomain;
                            cacheGroupPrincipal.Add(sid, domainGroupPrincipal);
                            this.logger.LogDebug("ResolveGroupPrincipal {0}\\{1} => resolu : {2} ms", groupDomain, sid, (DateTime.Now - start).TotalMilliseconds);
                            return domainGroupPrincipal;

                        }
                        else
                        {
                            this.logger.LogDebug("ResolveGroupPrincipal {0}\\{1} => NON resolu : {2} ms", groupDomain, sid, (DateTime.Now - start).TotalMilliseconds);
                        }
                    }
                }
            }

            return domainGroupPrincipal;
        }

        public virtual async Task<TUserFromDirectory> ResolveUserBySid(string sid, bool forceRefresh = false)
        {
            string KeyCache = KeyPrefixCacheUserSid + sid;
            return await ResolveUser(KeyCache, IdentityType.Sid, sid, forceRefresh);
        }

        public virtual async Task<TUserFromDirectory> ResolveUserByIdentityKey(string identityKey, bool forceRefresh = false)
        {
            string KeyCache = KeyPrefixCacheUserIdentityKey + identityKey;
            return await ResolveUser(KeyCache, (IdentityType)this.userIdentityKeyDomainService.GetIdentityKeyType(), identityKey, forceRefresh);
        }

        protected virtual async Task<TUserFromDirectory> ResolveUser(string KeyCache, IdentityType identityType, string key, bool forceRefresh = false)
        {

            TUserFromDirectory itemResolve;
            itemResolve = (TUserFromDirectory)await this.ldapRepositoryHelper.DistributedCache.Get<TUserFromDirectory>(KeyCache);
            if (itemResolve != null)
            {
                if (forceRefresh)
                {
                    await this.ldapRepositoryHelper.DistributedCache.Remove(KeyCache);
                    itemResolve = null;
                }
                else
                {
                    // Return null in case of empty element.
                    if (itemResolve.Login == null) return null;
                    return itemResolve;
                }
            }
            foreach (var userDomain in ldapDomainsUsers)
            {
                PrincipalContext searchContext = await PrepareDomainContext(userDomain);
                if (searchContext != null)
                {
                    var userPrincipal = await Task.Run(() => UserPrincipal.FindByIdentity(searchContext, identityType, key));
                    if (userPrincipal != null)
                    {
                        itemResolve = GetUser(userPrincipal, userDomain.Name);
                        break;
                    }
                }
            }

            // Add element empty in cache to not retrieve it several time. 
            if (itemResolve == null)
            {
                itemResolve = new TUserFromDirectory();
                itemResolve.Login = null;
            }
            await this.ldapRepositoryHelper.DistributedCache.Add(KeyCache, itemResolve, this.LdapCacheUserDuration);

            // Return null in case of empty element.
            if (itemResolve.Login == null) return null;
            return itemResolve;
        }
    }
}